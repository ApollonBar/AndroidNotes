### 一、定义

确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。  

也就是一个类在整个系统只能有一个实例，这样做的好处是防止创建多个重复对象消耗内存，而且操作 IO 和数据库等都是比较耗资源的，单例可以较少性能的开销。

### 二、简单示例

```
public class Singleton {
    private static Singleton instance = new Singleton;
    private Singleton () {
        
    }
    public static Singleton getInstance() {
        return instance;
    }
}
```

上面就是一个单例模式的简单使用示例，可以看到确实是自行实例化的，并且使用的是私有构造函数，目的是为了其他地方不能通过构造函数来创建该类的实例，只能通过公共的 getInstance() 方法获取该类的实例。

### 三、单例模式的多种实现方式

实现单例模式有多种方式，具体如下：

##### 1. 饿汉式（线程安全）

```
public class Singleton {
    private static Singleton instance = new Singleton();

    private Singleton() {
    }

    public static Singleton getInstance() {
        return instance;
    }
}
```

小结：在类加载的时候就初始化实例，虽然避免了多线程并发操作导致的线程安全问题，但是会造成内存的浪费，因为还没有使用这个对象就把它加载到内存中了。

##### 2. 懒汉式（线程不安全）

```
public class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

小结：只有第一次用到的时候才初始化实例，解决了饿汉式造成内存浪费的问题，但是多线程的时候是不安全的。例如有线程 A 与线程 B 同时执行，这时候就有可能 2 个线程都同时执行到 if (instance == null)，这样就创建了 2 个实例了。所以这种方式只适用于单线程。

注：详细的多线程并发请见我的另一篇文章-->[带你通俗易懂的理解——线程、多线程与线程池](https://github.com/wildma/AndroidNotes/blob/master/blogs/%E5%B8%A6%E4%BD%A0%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0.md)

##### 3. 懒汉式（线程安全）

```
public class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

小结：在 getInstance 方法上加了同步锁，这样有多个线程的时候会等前面的线程执行完了再执行当前线程，可以解决第二种懒汉式的线程安全问题。

##### 4. 双重校验锁（线程安全）

```
public class Singleton {
    private volatile static Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

小结：可以看到加了双重 if (instance == null) 的判断，并且同步锁放到了方法内部，新增的第一个判空可以避免每个线程过来都去执行同步锁，可以解决同步锁造成的效率低的问题。  

但是，instance = new Singleton(); 并不是一个原子操作，这一行代码可以分成 3 个步骤：

1. 给 instance 分配内存
2. 初始化 instance，即执行 new  Singleton();
3. 将 instance 对象指向分配的内存空间  

而且由于 JVM 具有指令重排的特性，也就是说无法保证上面的 3 个步骤是按 1>2>3 执行的，有可能是 1>3>2。例如线程 A 执行完第 1 步与第 3 步，而没有执行第 2 步，显然 instance 是不为空的，这个时候线程 B 刚好执行到 if (instance == null) ，发现不为空就直接返回 instance，但是由于一直没有执行到第 2 步，所以 instance 虽然不为空，但是是没有初始化完成的，所以调用一个没有初始化完成的实例肯定是有问题的。  

所以代码中使用了 volatile 关键字，因为它可以解决指令重排的问题，但是只能在 JDK 1.5 之后生效。而且使用 volatile 关键字也会影响一些性能问题。

##### 5. 静态内部类（线程安全）

```
public class Singleton {
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    private Singleton() {
    }

    public static final Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

小结：这种方式在 Singleton 类加载的时候并没有初始化实例，而是第一次调用 getInstance() 的时候才进行初始化，可以达到延迟加载对象的作用。并且 JVM 能确保 INSTANCE 只被实例化一次。也就是这种方式可以实现双重校验锁一样的效果，而且解决了使用 volatile 关键字只能在 JDK 1.5 之后生效和影响性能的问题。但是这种方式用的人还是比较少的。

##### 6. 枚举（线程安全）

```
public enum Singleton {
    INSTANCE;

    public void testMethod() {
    }
}
```

小结：可以说使用枚举的方式实现单例是目前最完美的方式，这种方式可以防止序列化与反射造成的创建多个实例的问题，而前面的 5 种方式默认情况是无法解决这个问题的。可能使用枚举的唯一缺点是可读性不高。
关于序列化与反射造成的创建多个实例的问题可以看看这篇文章——>[为什么要用枚举实现单例模式（避免反射、序列化问题）](http://www.cnblogs.com/chiclee/p/9097772.html)

### 四、总结

##### 单例模式使用场景

- 只需要一个实例对象。
- 需要频繁实例化然后销毁的对象。
- 创建比较耗时的对象，例如访问IO和数据库等资源。

##### 单例模式的优点与缺点

优点：

- 由于单例模式在内存中只有一个实例，对于需要频繁实例化然后销毁的对象可以减少内存开销。
- 由于单例只有一个实例，对于创建比较耗时或者耗资源的对象可以减少系统的性能开销。
- 可以避免对资源的多重占用。
- 可以在系统设置全局的访问点，优化和共享资源访问。

缺点：

- 单例模式一般没有接口，所以扩展困难，需要扩展只能修改原有的代码。
- 单例模式一般职责过多，所以与单一职责原则是有冲突的。

##### 选用哪种方式实现单例模式？

以上 6 种方式各有利弊（线程安全问题、性能问题、代码复杂度与可读性问题），所以需要根据自己的项目选择合适的方式。一般建议使用第三种线程安全的懒汉式（例如系统源码 LocalBroadcastManager 就是使用该种方式），如果涉及到序列化与反射则可以使用第六种枚举的方式。

### 参考资料
- 《设计模式之禅》
- 网上一些零散的博客
