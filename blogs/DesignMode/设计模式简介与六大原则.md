### 一、设计模式概括
设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它可以提高代码的可重用性，增强系统的可维护性，以及解决一系列的复杂问题。一名软件工程师搭建的框架是否健壮、是否易维护，很大程度取决于你是否运用了设计模式。是否懂得将设计模式运用到实际项目中也是区分初级工程师与高级工程师的其中一个重要因素。

### 二、设计模式六大原则

##### 1. 单一职责原则  
- **定义：** 一个类只有一个原因引起变化。也就是一个类只有一个职责，它就只负责一件事情。
- **通俗理解：** 例如类 A 负责两个不同的职责，分别是职责 B1 与职责 B2，当职责 B1 需要修改时，就会导致类 A 的修改，这样就有可能影响到职责 B2 的功能。为了解决修改职责 B1 影响职责 B2 的功能就有了“单一职责原则”，也就是可以根据“单一职责原则  ”分别创建类 A1 和类 A2，然后类 A1 负责职责 B1，类 A2 负责职责 B2，这样就解决了相互影响的问题。
- **好处：** 类的复杂性降低、可读性提高、可维护性提高、变更引起的风险降低。

##### 2. 里氏替换原则
- **定义：** 所有引用基类的地方必须能透明地使用其子类的对象。
- **通俗理解：** 即只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。
- **好处：** 增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。

##### 3. 依赖倒置原则
- **定义：** 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。
  （注：抽象在 Java 中指接口或抽象类，细节指实现类。）
- **通俗理解：** 因为低层模块和细节都是多变的，而抽象则比较稳定，所以只能低层模块和细节依赖抽象，而不是抽象依赖它们。也就是说要面向接口编程。
- **好处：** 降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。

##### 4. 接口隔离原则
- **定义：** 建立单一接口，不要建立臃肿庞大的接口。
- **通俗理解：** 也就是接口要尽量细化，提供给每个模块的都应该是专门的接口，提供给几个模块就应该有几个专门的接口，而不是建立一个臃肿庞大的接口来提供给所有的模块。
- **好处：** 对接口进行细化可以提高程序设计的灵活性，降低代码的耦合性；为每个模块提供专门的接口更容易提供定制服务。

##### 5. 迪米特法则
- **定义：** 一个对象应该对其他对象有最少的了解。
- **通俗理解：** 例如有类 A 与类 B ，类 A 需要依赖类 B，这时类 B 只需要提供类 A 需要的 public 方法即可，而不应该暴露更多细节给类 A 知道，这样可以降低类 A 与类 B 之间的耦合。
- **好处：** 可以降低类与类之间的耦合。

##### 6. 开闭原则
- **定义：** 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
- **通俗理解：** 一个软件产品在迭代升级的过程中总会发生一些变化，但是变化的内容我们不应该在原有的代码上修改，而应该通过扩展的方式来实现新的需求。例如很多开源库都会预留接口让使用者去自定义自己个性的需求，而不是让使用者修改开源库的源码来达到自己的需求。
- **好处：** “对修改关闭”可以减少对原有代码的修改，保持历史代码的纯洁性，提高系统的稳定性。

### 三、设计模式分类
由 GoF 合著的书籍《设计模式 - 可复用的面向对象软件元素》中一共提到了 23 种设计模式，这些模式可以分为三大类：
- 创建型模式（5种）：单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式。
- 结构型模式（7种）：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
- 行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

### 参考资料
- 《设计模式之禅》
- 网上一些零散的博客
